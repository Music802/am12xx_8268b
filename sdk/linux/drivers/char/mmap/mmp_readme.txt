

用户虚拟空间Vm_area_struct

Vk空间vm_struct

物理内存

Vma->nopage
 

我们需要实现nopage方法，动态建立对应页表，而在该方法中核心任务是寻找到vk地址对应的内核逻辑地址[4]。这必然需要我们做以下工作：

a)         找到vmalloc虚拟内存对应的内核页表，并寻找到对应的内核页表项。

b)        获取内核页表项对应的物理页框指针。

c)        通过页框得到对应的内核逻辑地址。
基本函数

我们实例将利用一个虚拟字符驱动程序，驱动负责将一定长的内核虚拟地址(vmalloc分配的)映射到设备文件上，以便可以通过访问文件内容来达到访问内存的目的。这样做的最大好处是提高了内存访问速度，并且可以利用文件系统的接口编程（设备在Linux中作为特殊文件处理）访问内存，降低了开发难度。

 

 Map_driver.c就是我们的虚拟字符驱动程序，不用说它要实现文件操作表（file_operations――字符驱动程序主要做的工作便是实现该结构）中的，为了要完成内存映射，除了常规的open/release操作外，必须自己实现mmap操作，该函数将给定的文件映射到指定的地址空间上，也就是说它将负责把vmalloc分配的内核地址映射到我们的设备文件上。

我们下面就谈谈mmap操作的实现细节：

文件操作的mmap操作是在用户进行系统调用mmap[5]时被执行的，而且在调用前内核已经给用户找到并分配了合适的虚拟内存区域vm_area_struct，这个区域将代表文件内容，所以剩下要做的便是如何把虚拟区域和物理内存挂接到一起了，即构造页表。由于我门前面所说的原因，我们系统中页表需要动态分配，因此不可使用remap_page_range函数一次分配完成，而必须使用虚拟内存区域自带的nopage方法，在现场构造页表。这样以来，文件操作的mmap的方法只要完成“为它得到的虚拟内存区域绑定对应的操作表vm_operations”即可。于是主要的构造工作就落在了vm_operations中的nopage方法上了。

Nopage方法中核心内容上面已经提到了是“寻找到vk地址对应的内核逻辑地址”，这个解析内核页表的工作是需要自己编写辅助函数vaddr_to_kaddr来完成的，它所作的工作概括来讲就是上文提到的a\b\c三条。

有关整个任务执行路径请看下图。

STEP BY STEP

编译map_driver.c为map_driver.o模块,具体参数见Makefile

加载模块 ：insmod map_driver.o

生成对应的设备文件

1 在/proc/devices下找到map_driver对应的设备命和设备号：grep mapdrv /proc/devices

2 建立设备文件mknod  mapfile c 254 0  （在我系统里设备号为254）

    利用maptest读取mapfile文件，将取自内核的信息（”ok”――我们在内核中在vmalloc分配的空间中填放的信息）打印到用户屏幕。

 

全部程序下载 mmap.tar （感谢Martin Frey，该程序主体出自他的灵感）

 

 

 

 

 

 

[1] 还有些情况必须要求内存连续，比如DMA传输中使用的内存，由于不涉及页机制所以必须连续分配。

[2] 这种存储池的思想在计算机科学里广泛应用，比如数据库连接池、内存访问池等等。

[3] 构建用户也表项，除了使用nopage一次一页的动态构造，还又一种方法remap_page_range可以一次构造一段内存范围的也表项，但显然这个方法时针对物理内存连续被分配时使用的，而我们vk对应的物理内存并非连续，所以这里使用nopage。

[4] 很多人一定会问，为什么不直接找到物理地址那，而要找内核逻辑地址呢？ 没错，我们本意应该是获得物理地址，但是为了利用内核提供的一些现成的例程，如virt_to_page等（它们都是针对内核逻辑地址而言的），我们不妨转化成内核逻辑地址来做，别忘了内核逻辑地址与理地址仅仅相差一个偏移量。

[5] 系统调用mmap原形是void *mmap2(void *start, size_t length, int prot, int flags, int fd, off_t pgoff)。
